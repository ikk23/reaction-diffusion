// 1D simple gene drive. Track the number of drive alleles at all x.

// same initialization as before, but scale down the population size
initialize() {
	defineConstant("CAPACITY", 3927);
	defineConstant("DENSITY_INTERACTION_DISTANCE", 0.002);
	defineConstant("DRIVE_FITNESS_VALUE", 0.95);
	defineConstant("DROP_SIZE", 100); // represent roughly 10% of the population to start
	defineConstant("DROP_RADIUS", 0.01);
	defineConstant("EMBRYO_RESISTANCE_RATE", 0.05); 
	defineConstant("GERMLINE_RESISTANCE_RATE", 0.05);
	defineConstant("GROWTH_AT_ZERO_DENSITY", 6);
	defineConstant("HETEROZYGOUS_DROP", T);
	defineConstant("HOMING_DRIVE", T);
	defineConstant("NUM_GRNAS", 1);
	defineConstant("RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE", T);
	defineConstant("R1_OCCURRENCE_RATE", 0.0);
	defineConstant("SPEED", 0.01);
	// */    // End header.
	
	// Below are defaults - won't change from drive to drive
	defineConstant("BASELINE_HOMING_SUCCESS_RATE", 1.0); //default 1.0
	defineConstant("EQUILIBRIUM_BIN_POPULATION", 0.5*CAPACITY/20);
	defineConstant("FEMALE_SPEED", SPEED);
	defineConstant("FEMALE_ONLY_DROP", F);
	defineConstant("GENE_UTILITY_TRANSFORMATION_DRIVE", F);
	defineConstant("GENE_UTILITY_TRANSFORMATION_FITNESS", 0.95);
	defineConstant("GRNA_SATURATION_SIMULATED", F);
	defineConstant("HOMING_EDGE_EFFECT", 0.1);
	defineConstant("HOMING_PHASE_CUT_RATE", 1.0);
	defineConstant("INBREEDING_AVOIDANCE_FACTOR", 0.0);
	defineConstant("LATE_GERMLINE_RESISTANCE_RATE", 0.0); //default 0.9
	defineConstant("MATING_DISTANCE", SPEED);
	defineConstant("NUM_CUT_PHASES", 1);
	defineConstant("R2_FITNESS_VALUE", 1.0);
	defineConstant("REPRISING_BOUNDARIES", T);
	
	// For mortality rate as a function of age:
	// Some females are allowed to survive two generations:
	defineConstant("RATE_FEMALES_SURVIVE", 0.0);
	
	// This simulation will use a non-Wright-Fisher model.
	initializeSLiMModelType("nonWF");
	
	// This simulation will tske place accross continuous space.
	// By default, model occurs in a torroidal space to prevent edge effects.
	// The model tracks pedigrees in order to implement inbreeding avoidance.
	if (REPRISING_BOUNDARIES)
		initializeSLiMOptions(keepPedigrees = T, dimensionality = "x"); //for 1-D
	else
		initializeSLiMOptions(keepPedigrees=T, dimensionality="x", periodicity="x");
	
	
	// Four variations: Wild type, drive, r1 resistance, r2 resistance.
	wt = initializeMutationType("m1", 0.5, "f", 0.0);
	dr = initializeMutationType("m2", 0.5, "f", 0.0);
	r1 = initializeMutationType("m3", 0.5, "f", 0.0);
	r2 = initializeMutationType("m4", 0.5, "f", 0.0);
	cut = initializeMutationType("m5", 0.5, "f", 0.0);
	gap = initializeMutationType("m6", 0.5, "f", 0.0);
	variations = c(wt, dr, r1, r2, cut, gap);
	
	// Variations are all part of g1 genome element.
	initializeGenomicElementType("g1", variations, c(1, 1, 1, 1, 1, 1));
	
	// Element is NUM_GRNAS long, each spot on the element representing a GRNA target location.
	initializeGenomicElement(g1, 0, NUM_GRNAS - 1);
	
	// These mutations overwrite one another.
	variations.mutationStackPolicy = "l";
	variations.mutationStackGroup = 1;
	
	// No mutation in this model.
	initializeMutationRate(0.0);
	initializeRecombinationRate(0.0);
	
	// Simulate sexual reproduction: A for autosome
	initializeSex("A");
	
	// Mate searching: Default interaction has strength 1 for individuals within max distance, 0 for others.
	initializeInteractionType(1, "x", reciprocal=T, maxDistance=MATING_DISTANCE);
	// Adult competition:
	initializeInteractionType(2, "x", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
	// For now, just modeling interaction with flat strength of 1.
	// i2.setInteractionFunction("n", 1.0, DENSITY_INTERACTION_DISTANCE);
	
	//Used to track Ripley's L between wt individuals for chasing analysis when TRACK_RIPLEYS_L is T
	initializeInteractionType(3, "x", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
	
	// Constants based on other constants:
	// Rate of expected competition
	defineConstant("EXPECTED_ADULT_COMPETITION", CAPACITY * 2*DENSITY_INTERACTION_DISTANCE); //now interaction is evaluated in a line
	
	
	// From SLiM manual - look up location of the Rscript utility
	if (fileExists("/usr/bin/Rscript"))
		defineConstant("RSCRIPT", "/usr/bin/Rscript");
	else if (fileExists("/usr/local/bin/Rscript"))
		defineConstant("RSCRIPT", "/usr/local/bin/Rscript");
	else
		stop("Couldn't find Rscript.");
}

// Functions from before
//// FUNCTION FOR EVALUATING POPULATION SUPPRESSION WITH RECESSIVE FEMALE or MALE STERILITY STYLE SUPPRESSION.
function (logical)isRecessiveSterilitySuppressed(o<Individual>$ ind) {
	// Check both chromosomes for drive and type 2 resistance allele. These are the only variants that affect suppression.
	
	// Individual cannot reproduce if both chromosomes have either a drive or an r2.
	if ((ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS | ind.genome1.countOfMutationsOfType(m4) > 0) & (ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS| ind.genome2.countOfMutationsOfType(m4) > 0))
		return T;
	return F;
}


//// HELPER FUNCTION FOR FORMING A RESISTANCE ALLELE AT A GIVEN LOCUS.
function (void)addResistanceAllele(o<Genome>$ genome, i$ locus) {
	// Resistance alleles form at a specified rate.	m3 is r1, m4 is r2.
	genome.addNewDrawnMutation(ifelse((runif(1) < R1_OCCURRENCE_RATE), m3,m4), locus);
}


//// FUNCTION FOR CAS9 EFFECTS IN THE GERMLINE.
function (void)germline(o<Genome>$ child_chromosome, o<Individual>$ parent, f$ resistance_rate) {
	// Determine presence of drive in this parent.
	parent_drive_count = sum(parent.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	// If parent doesn't have drive allele, nothing happens in germline.
	if (!parent_drive_count)
		return;
	
	// Chromosome must have wt to cut, or nothing happens.
	if (child_chromosome.countOfMutationsOfType(m1) == 0)
		return;
	
	// Using the resistance rate passed to the function,
	// determine the per phase cut rate.
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	per_phase_cut_rate = 1 - (1 - resistance_rate)^(1 / (NUM_CUT_PHASES * grna_factor));
	
	// Determine if cas9 cuts the chromosome in the germline.
	casCut(child_chromosome, per_phase_cut_rate);
}


//// FUNCTION FOR CAS9 EFFECTS IN EMBRYO.
function (void)embryo(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ mother) {
	// Determine presence of drive in this mother.
	mother_drive_count = sum(mother.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	// If mother doesn't have drive allele, nothing happens in embryo.
	if (!mother_drive_count)
		return;
	
	// Determine the per phase cut rate.
	if (HOMING_DRIVE & sum(mother.genomes.countOfMutationsOfType(m1) == NUM_GRNAS) == 1)
		// Special case for homing drive individual that is dr/wt based on experimental data.
		cas_factor = 1.82;
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	per_phase_cut_rate = 1 - (1 - EMBRYO_RESISTANCE_RATE)^(mother_drive_count / (NUM_CUT_PHASES * grna_factor));
	
	// Then pass this rate as an argument to  the casCut funtion to
	// determine if cas9 cuts in the embryo for each chromosome.
	casCut(child_chromosome_1, per_phase_cut_rate);
	casCut(child_chromosome_2, per_phase_cut_rate);
}


//// FUNCTION FOR CAS9 CUTTING A TARGET CHROMOSOME.
function (void)casCut(o<Genome>$ chromosome, f$ per_phase_cut_rate) {
	// If chromosome has no wild type targets to cut, cas9 does nothing.
	if (chromosome.countOfMutationsOfType(m1) == 0)
		return;
	
	// Vector of possible loci for cas9 to cut:
	wt_loci = chromosome.positionsOfMutationsOfType(m1);
	
	// In each cut phase...
	for (i in seqLen(NUM_CUT_PHASES)) {
		// At each possible locus...
		for (j in seqAlong(wt_loci)) {
			// Check to see if cas9 cuts...
			if (runif(1) < per_phase_cut_rate) {
				// Convert the locus temporarily to an m5,
				// representing that this site is being cut.
				chromosome.addNewDrawnMutation(m5, wt_loci[j]);
			}
		}
		// If any cuts were made...
		if (chromosome.countOfMutationsOfType(m5)) {
			cut_loci = chromosome.positionsOfMutationsOfType(m5);
			// If just one cut is made, create an R1 or R2 resistance allele.
			if (chromosome.countOfMutationsOfType(m5) == 1)
				addResistanceAllele(chromosome, cut_loci[0]);
			else {
				// If multiple cuts are made in the same cut phase, loss of
				// function results. Convert leftmost site to m4 (R2)
				// everthing else through the rightmost site to m6 (cut).
				number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
				for (index in seqLen(number_of_cuts))
					chromosome.addNewDrawnMutation(m6, cut_loci[0] + index + 1);
				chromosome.addNewDrawnMutation(m4, cut_loci[0]);
			}
			// Because some wt loci may have been cut out of the
			// chromosome, remake the vector of possible cut sites.
			if (chromosome.countOfMutationsOfType(m1) == 0)
				return;
			wt_loci = chromosome.positionsOfMutationsOfType(m1);
		}
	}
}


//// FUNCTION FOR SIMULATING HOMING THAT OCCURS DURING HOMOLOGY DIRECTED REPAIR.
function (void)hdr(o<Genome>$ chromosome, o<Individual>$ parent) {
	// If chromosome has no wild type targets to cut, cas9 does nothing.
	if (chromosome.countOfMutationsOfType(m1) == 0)
		return;
	// Determine presence of drive in this parent. If parent doesn't have drive allele, nothing happens in germline.
	if (parent.countOfMutationsOfType(m2)==0)
		return;
	
	// Rate of cutting occurs at the HOMING_PHASE_CUT_RATE, modified by gRNA saturation, if toggled on.
	cut_rate = HOMING_PHASE_CUT_RATE;
	if (GRNA_SATURATION_SIMULATED)
		cut_rate = 1 - (1 - HOMING_PHASE_CUT_RATE)^(1/NUM_GRNAS);
	
	// Vector of possible loci.
	wt_loci = chromosome.positionsOfMutationsOfType(m1);
	
	// At each possible locus...
	for (i in seqAlong(wt_loci))
		// Check to see if cas9 cuts...
		if (runif(1) < cut_rate)
			// Convert the locus temporarily to an m5,
			// representing that this site is being cut.
			chromosome.addNewDrawnMutation(m5, wt_loci[i]);
	
	// If any cuts were made...
	if (chromosome.countOfMutationsOfType(m5)) {
		// Determine how extreme the cuts are relative to the target package (the drive).
		cut_loci = chromosome.positionsOfMutationsOfType(m5);
		leftmost_cut_index = cut_loci[0];
		rightmost_cut_index = cut_loci[size(cut_loci) - 1];
		// Sections that have already been cut out of the chromosome
		// also contribute to the size of the cut section.
		missing_loci = chromosome.positionsOfMutationsOfType(m6);
		// Adjusted indecies are amounts by which the cut ends differ
		// from the perfect cut that spans the entire target area.
		adjusted_left_index = leftmost_cut_index - sum(missing_loci < leftmost_cut_index);
		rightmost_cut_index = rightmost_cut_index + sum(missing_loci > rightmost_cut_index);
		adjusted_right_index = NUM_GRNAS - 1 - rightmost_cut_index;
		
		successful_homing_rate = BASELINE_HOMING_SUCCESS_RATE * (1 - HOMING_EDGE_EFFECT * adjusted_left_index) * (1 - HOMING_EDGE_EFFECT * adjusted_right_index);
		
		// Check to see if homing succeeds.
		if (runif(1) < successful_homing_rate)
			for (i in seqLen(NUM_GRNAS))
				chromosome.addNewDrawnMutation(m2, i);
		else {
			// A small percentage of of individuals have complete failures of the homing drive,
			// resulting in the entire section of the chromosome becoming a resistance allele.
			total_failure_avoidance_rate = 0.9 * (1 - 0.1 * adjusted_left_index) * (1 - 0.1 * adjusted_right_index);
			
			if (runif(1) < total_failure_avoidance_rate) {
				// Some catastrophic failures become all R1, at the following rate:
				total_r1_rate = 0.001 * (1 + adjusted_right_index - adjusted_left_index);
				for (i in seqLen(NUM_GRNAS))
					chromosome.addNewDrawnMutation(m4, i);
			}
			// If neither homing nor a catastrophic failure occur, normal repair happens.
			else {
				// If just one cut was made, create an R1 or R2 resistance allele.
				if (chromosome.countOfMutationsOfType(m5) == 1)
					addResistanceAllele(chromosome, cut_loci[0]);
				else {
					// If mutlple cuts were made, leftmost site to m4 (R2),
					// everthing else through the rightmost site to m6 (cut).
					number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
					for (index in seqLen(number_of_cuts))
						chromosome.addNewDrawnMutation(m6, cut_loci[0] + index + 1);
					chromosome.addNewDrawnMutation(m4, cut_loci[0]);
				}
			}
		}
	}
}


//// HELPER FUNCTION TO OVERWRITE ONE GENOME WITH ANOTHER.
function (void)copy_genome(o<Genome>$ source, o<Genome>$ destination) {
	for (i in seqAlong(source.positionsOfMutationsOfType(m1))) //m1 loci (wt)
		destination.addNewDrawnMutation(m1, source.positionsOfMutationsOfType(m1)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m2))) //m2 loci (dr)
		destination.addNewDrawnMutation(m2, source.positionsOfMutationsOfType(m2)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m3))) //m3 loci (r1)
		destination.addNewDrawnMutation(m3, source.positionsOfMutationsOfType(m3)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m4))) //m4 loci (r2)
		destination.addNewDrawnMutation(m4, source.positionsOfMutationsOfType(m4)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m5))) //m5 loci (cut)
		destination.addNewDrawnMutation(m5, source.positionsOfMutationsOfType(m5)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m6))) //m6 loci (gap)
		destination.addNewDrawnMutation(m6, source.positionsOfMutationsOfType(m6)[i]);
}


//// RULES FOR FITNESS BASED ON GENOTYPE.
function (f$)genotypeFitness(o<Individual>$ ind) {
	
	// If the drive is one that targets a gene function, two copies of either the gene or r2 incur an associated fitness cost.
	if (GENE_UTILITY_TRANSFORMATION_DRIVE) {
		if ((ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS | ind.genome1.countOfMutationsOfType(m4) > 0) & (ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS | ind.genome2.countOfMutationsOfType(m4) > 0))
			return GENE_UTILITY_TRANSFORMATION_FITNESS;
		return 1.0;
	}
	
	// Representation of the value of the two chromosomes. Check for drive or wt to get the baseline value.
	c1_value = ifelse(ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS, DRIVE_FITNESS_VALUE, 1.0);
	c2_value = ifelse(ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS, DRIVE_FITNESS_VALUE, 1.0);
	
	// Check both chromosomes for resistance allele.
	// If R2_FITNESS_VALUE is lower than 1.0, r2 mutations lower fitness.
	if (ind.genome1.countOfMutationsOfType(m4) > 0)
		c1_value = c1_value * R2_FITNESS_VALUE;
	if (ind.genome2.countOfMutationsOfType(m4) > 0)
		c2_value = c2_value * R2_FITNESS_VALUE;
	
	// Return fitness for individual with this genotype.
	return sqrt(c1_value * c2_value);
}

// Same reproduction as before

//// REPRODUCTION RULES FOR EACH FEMALE.
reproduction(NULL, "F") {
	
	// Check if female is sterile
	if (RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE)
		if (isRecessiveSterilitySuppressed(individual))
			return;
	
	all_neighbors = i1.nearestNeighbors(individual, subpop.individualCount);
	neighbors = all_neighbors[all_neighbors.sex == "M"];
	if (size(neighbors) == 0)
		return;
	attempt_no = 0;
	while (1) {
		mate_no = 0;
		if (size(neighbors) > 1)
			mate_no = rdunif(1, max=size(neighbors) - 1);
		selected_mate = neighbors[mate_no];
		mate_attractiveness = genotypeFitness(selected_mate);
		if (selected_mate.pedigreeParentIDs[0] == individual.pedigreeParentIDs[0] & individual.pedigreeParentIDs[0] != -1)
			mate_attractiveness = mate_attractiveness * (1 - INBREEDING_AVOIDANCE_FACTOR);
		if (runif(1) < mate_attractiveness)
			break;
		attempt_no = attempt_no + 1;
		if (attempt_no == 9)
			return;
	}
	
	// Amount of competition faced per expected competition.
	adult_density_force = i2.totalOfNeighborStrengths(individual);
	competition_ratio = adult_density_force / EXPECTED_ADULT_COMPETITION; //allows higher growth when interaction strength is lower
	actual_competition_factor = GROWTH_AT_ZERO_DENSITY/ ((GROWTH_AT_ZERO_DENSITY-1) * competition_ratio + 1);
	
	// Offspring number based on binomial distrobution.
	// p for binomial draw. Number of offspring varies with female genes and competition.
	p = genotypeFitness(individual) * actual_competition_factor * 0.04 / (1 + RATE_FEMALES_SURVIVE);
	num_offspring = rbinom(1, 50, p);
	
	
	// Add offspring to the subpopulation.
	// *WILL  NEED TO PLAY WITH DISPERSAL KERNEL HERE*
	for (i in seqLen(num_offspring)) {
		offspring = subpop.addCrossed(individual, selected_mate);
		if (!isNULL(offspring)) {
			if (REPRISING_BOUNDARIES) {
				// redraw coordinates so that the offspring stays in bounds
				do position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
				while (!individual.subpopulation.pointInBounds(position));
				offspring.setSpatialPosition(position);
			}
			else {
				// edges wrap around
				position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
				offspring.setSpatialPosition(p1.pointPeriodic(position));
			}
		}
	}
}

// HOMING GENE DRIVE RULES
1: modifyChild() {
	
	// Apply effects that happen in the germline.
	// First, resistance alleles form.
	germline(childGenome1, parent1, GERMLINE_RESISTANCE_RATE);
	germline(childGenome2, parent2, GERMLINE_RESISTANCE_RATE);
	// Next, homology directed repair allows for homing to occur.
	hdr(childGenome1, parent1);
	hdr(childGenome2, parent2);
	// Then additional resistance alleles form.
	germline(childGenome1, parent1, LATE_GERMLINE_RESISTANCE_RATE);
	germline(childGenome2, parent2, LATE_GERMLINE_RESISTANCE_RATE);
	
	// Apply effects that happen in the embryo.
	embryo(childGenome1, childGenome2, parent1);
	
	return T;
}

//// COLOR RULES FOR SLIM GUI DISPLAY.
early() {
	all = sim.subpopulations.individuals;
	
	all.color = "blue"; // wts are blue
	
	two_res = (all.genome1.countOfMutationsOfType(m4) | all.genome1.countOfMutationsOfType(m3) == NUM_GRNAS) & (all.genome2.countOfMutationsOfType(m4) | all.genome2.countOfMutationsOfType(m3) == NUM_GRNAS);
	
	all[two_res].color = "yellow"; // resistance homozygotes will be yellow
	
	one_drive = all.countOfMutationsOfType(m2) == NUM_GRNAS;
	
	two_drive = all.countOfMutationsOfType(m2) == 2*NUM_GRNAS;
	
	all[one_drive].color = "red"; // drive carriers are red
	
	all[two_drive].color = "red";
}

// Output the number of drive alleles at each x position
late() {
	i1.evaluate();
	i2.evaluate();
	
	//by default, create non-overlapping generations
	all = sim.subpopulations.individuals;
	all.fitnessScaling = 0.0;
}

10: late() {
	
	//subset all non-drive individuals
	all = sim.subpopulations.individuals;
	one_drive = all[all.countOfMutationsOfType(m2) == NUM_GRNAS];
	two_drive = all[all.countOfMutationsOfType(m2) == 2*NUM_GRNAS];
	
	het_xpos = one_drive.x; // each one counts once
	hom_xpos = two_drive.x;
	
	width = 0.01;
	x_intervals = seq(0.0,1.0,width);
	n = length(x_intervals);
	count_vector = rep(0,n);
	
	
	// divide the 0-1 x range into increments of 0.01
	for (i in seqLen(n)){
		start = x_intervals[i];
		end = start + width;
		
		// count the number of drive alleles in this interval
		het_drive_in_cell = (het_xpos >= start) & (het_xpos < end);
		hom_drive_in_cell = (hom_xpos >= start) & (hom_xpos < end);
		
		num_het_in_interval = size(het_xpos[het_drive_in_cell]);
		num_hom_in_interval = size(hom_xpos[hom_drive_in_cell]);
		num_drive_alleles_in_interval = num_het_in_interval + (2*num_hom_in_interval);
		count_vector[i] = num_drive_alleles_in_interval;
	}
	
	// Output this vector to the plot
	// From SLiM manual page 294-295
	rstr = paste('{',
		'x = c(' + paste(x_intervals,sep=',') + ')',
		'u_x = c(' + paste(count_vector,sep=',') + ')',
		'n =' + 2*CAPACITY,
		't =' + sim.generation,
		'png(width=4, height=4, units="in", res=72, file="' + pngPath + '")',
		'par(mar=c(4.0, 4.0, 1.5, 1.5))',
		'plot(x=x, y=u_x, xlim=c(0.0, 1.0), ylim=c(0, n), type="l",xlab="x", ylab="u(x)", main=paste0("t=",t))',
		'box()',
		'dev.off()',
		'}', sep="\n");
	
	scriptPath = writeTempFile("plot_", ".R", rstr); system(RSCRIPT, args=scriptPath); deleteFile(scriptPath);
	
	//// conditions that may stop the simulation for SUPPRESSION drives:
	// population size
	pop_size = length(all);
	males = all[all.sex=="M"];
	num_males = length(males);
	females = all[all.sex=="F"];
	num_females = length(females);
	
	//count of chromosomes
	num_y = num_males;
	num_x = 2*num_females + num_males;
	num_autosomal_chromosomes = 2*pop_size;
	
	//allele counts
	num_wt = sum(all.genomes.countOfMutationsOfType(m1)==NUM_GRNAS);
	num_dr = sum(all.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
	rate_dr = num_dr/num_autosomal_chromosomes;
	
	this_gen = sim.generation;
	
	catn("Generation: " + this_gen + " rate_drive = " + rate_dr);
	
	//1-drive was lost and wt population remained
	if (num_dr == 0 & pop_size>0) {
		catn("POP_PERSISTS:: " + this_gen);
		sim.simulationFinished();
	}
	
	//2-equilibrium state attained
	if (rate_dr== 1 & pop_size > 0) {
		catn("EQUILIBRIUM:: " + this_gen);
		sim.simulationFinished();
	}
	
	//3-suppression occurs
	if (pop_size == 0){
		catn("SUPPRESSED:: " + this_gen);
		sim.simulationFinished();
	}

}

//// START THE SIMULATION BY ADDING AN INITIAL WILD POPULATION.
1 {
	// Start with a population of wild-type.
	sim.addSubpop("p1", CAPACITY);
	
	all = p1.individuals;
	all.genomes.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));
	
	// Start individuals scattered at random.
	all.x = p1.pointUniform(CAPACITY);
	
	// From SLiM manual p.293
	// This file will be placed in /tmp or a subdirectory of tmp
	defineConstant("pngPath", writeTempFile("plot_", ".png", ""));
	
	// If we're running in SLiMgui, open a plot window
	if (exists("slimgui")) slimgui.openDocument(pngPath);

}

// Drive drop
10 {
	sim.addSubpop("p2", DROP_SIZE);
	
	drop = p2.individuals;
	
	drop.genomes.addNewDrawnMutation(m2,seqLen(NUM_GRNAS));
	
	// For heterozygous drop, one of the chromosomes is set to wild type:
	if (HETEROZYGOUS_DROP)
		drop.genome2.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));
	
	// Move all the individuals from the drop into p1:
	p1.takeMigrants(drop);
	
	drop.x = runif(DROP_SIZE, 0, DROP_RADIUS);
	drop.color = "red";
}


////output 1000 generations after drop if simulation hasn't ended already
1010 late() {
	
	all = p1.individuals;
	has_drive = sum(all.countOfMutationsOfType(m2) >= NUM_GRNAS);
	rate_has_drive = has_drive/size(all);
	
	catn("ENDING_AFTER_1000:: " + rate_has_drive); //show the rate of individuals with drive 
	sim.simulationFinished();
}
